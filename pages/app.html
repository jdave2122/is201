<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            background: #1a1a1a;
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #333333;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            text-align: center;
            width: 95%;
            max-width: 800px;
            border: 3px solid #444;
        }
        h1 {
            color: #ffc107;
            text-shadow: 2px 2px #000;
            font-size: 1.8em;
            margin-bottom: 20px;
        }
        #menuScreen button {
            background-color: #4CAF50;
            color: white;
            border: 2px solid #388E3C;
            padding: 15px 25px;
            margin: 10px;
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            display: block;
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            transition: all 0.2s;
        }
        #menuScreen button:hover {
            background-color: #66BB6A;
        }
        .game-area-wrapper {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            margin-top: 15px;
        }
        canvas {
            background-color: #000;
            border: 4px solid #555;
        }
        #goofyKey, #battleKey, #mazeKey {
            text-align: left;
            font-size: 0.6em;
            padding: 10px;
            background: #222;
            border-radius: 5px;
            width: 160px;
            border: 2px solid #555;
        }
        #goofyKey h4, #battleKey h4, #mazeKey h4 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
            color: #ffc107;
            font-size: 1.2em;
        }
        #goofyKey ul, #battleKey ul, #mazeKey ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #goofyKey li, #battleKey li {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            line-height: 1.2;
        }
        #mazeKey p {
            font-size: 1.1em;
            line-height: 1.4;
            text-align: center;
        }
        .key-color {
            display: inline-block;
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border: 1px solid #777;
            flex-shrink: 0;
        }
        #reverseStatus {
            color: #ff4d4d;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
            font-size: 1.1em;
        }
        .scores {
            display: flex;
            justify-content: space-around;
            padding: 10px;
            font-size: 0.9em;
        }
        #message {
            color: #ffeb3b;
            font-size: 0.8em;
            height: 20px;
            margin-top: 5px;
        }
        .ingame-button {
            background-color: #f44336;
            color: white;
            border: 2px solid #d32f2f;
            padding: 10px 20px;
            margin-top: 15px;
            font-family: inherit;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }
        .ingame-button:hover {
            background-color: #e57373;
        }
        .nav-link {
            display: block;
            margin-top: 20px;
            color: #ffc107;
            text-decoration: none;
            font-size: 0.8em;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div id="menuScreen">
            <h1>SNAKE</h1>
            <button onclick="startGame('normal')">Normal Mode</button>
            <button onclick="startGame('goofy')">Goofy Mode</button>
            <button onclick="startGame('battle')">Battle Mode (2P)</button>
            <button onclick="startGame('easyMaze')">Easy Maze</button>
            <button onclick="startGame('hardMaze')">Hard Maze</button>
        </div>

        <div id="gameScreen" style="display: none;">
            <div class="scores">
                <span id="scoreDisplay1">SCORE: 0</span>
                <span id="scoreDisplay2">HIGH: 0</span>
            </div>
            <div id="message"></div>
            <div class="game-area-wrapper">
                <canvas id="gameCanvas"></canvas>
                <div id="goofyKey" style="display: none;">
                    <h4>Goofy Key</h4>
                    <ul>
                        <li><span class="key-color" style="background-color: #00ffff;"></span>Super (+3)</li>
                        <li><span class="key-color" style="background-color: #ffff00;"></span>Limb (+3)</li>
                        <li><span class="key-color" style="background-color: #9400D3;"></span>Moving</li>
                        <li><span class="key-color" style="background-color: #FFA500;"></span>Reverse</li>
                        <li><span class="key-color" style="background-color: #FFFFFF;"></span>Shrink (-2)</li>
                        <li><span class="key-color" style="background-color: #808080;"></span>Obstacles</li>
                        <li><span class="key-color" style="background-color: #FFD700;"></span>Bonus Game</li>
                    </ul>
                    <div id="reverseStatus" style="display: none;">REVERSED! <span id="reverseTimer"></span></div>
                </div>
                 <div id="battleKey" style="display: none;">
                    <h4>Battle Key</h4>
                    <ul>
                        <li><span class="key-color" style="background-color: #ffff00;"></span>Speed Up</li>
                        <li><span class="key-color" style="background-color: #9400D3;"></span>Slow Foe</li>
                        <li><span class="key-color" style="background-color: #00ffff;"></span>Grow Foe</li>
                    </ul>
                </div>
                <div id="mazeKey" style="display: none;">
                    <h4>Maze Rules</h4>
                    <p>Only walls will end the game. You can reverse on yourself!</p>
                </div>
            </div>
            <button onclick="showMenu()" class="ingame-button">Back to Menu</button>
        </div>

        <a href="scratch.html" class="nav-link">‚Üê Back to Scratch Page</a>
    </div>

    <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menuScreen = document.getElementById('menuScreen');
        const gameScreen = document.getElementById('gameScreen');
        const scoreDisplay1 = document.getElementById('scoreDisplay1');
        const scoreDisplay2 = document.getElementById('scoreDisplay2');
        const messageEl = document.getElementById('message');
        const goofyKey = document.getElementById('goofyKey');
        const battleKey = document.getElementById('battleKey');
        const mazeKey = document.getElementById('mazeKey');
        const reverseStatus = document.getElementById('reverseStatus');
        const reverseTimerEl = document.getElementById('reverseTimer');

        // --- GAME STATE ---
        let currentModeName, gameMode, gridSize, tileSize, gameLoop, gameOver, gameSpeed;
        let snakes = [], apples = [], obstacles = [], highScore = 0;
        let goofyColors = ['#ff00ff', '#00ffff', '#ffff00', '#ff9900', '#00ff00'];
        let colorIndex = 0;
        let inMinigame = false, minigame, showingMinigameInstructions = false, isPausedForCountdown = false;
        let minigameInstructionTimeout, minigameInstructionCountdownInterval, minigameTimerInterval;
        let maze = [];

        // --- GAME MODES CONFIG ---
        const gameModes = {
            normal: { gridSize: 15, tileSize: 30, appleCount: 1, speedUp: false, goofy: false, battle: false, maze: false, startSpeed: 150 },
            goofy: { gridSize: 15, tileSize: 30, appleCount: 2, speedUp: true, goofy: true, battle: false, maze: false, startSpeed: 150 },
            battle: { gridSize: 20, tileSize: 25, appleCount: 3, speedUp: true, goofy: false, battle: true, maze: false, startSpeed: 250 },
            easyMaze: { gridSize: 20, tileSize: 22, appleCount: 1, speedUp: true, goofy: false, battle: false, maze: true, pathWidth: 2, vision: 3, startSpeed: 200 },
            hardMaze: { gridSize: 20, tileSize: 22, appleCount: 1, speedUp: true, goofy: false, battle: false, maze: true, pathWidth: 1, vision: 2, startSpeed: 150 }
        };

        function startGame(modeName) {
            currentModeName = modeName;
            gameMode = gameModes[modeName];
            gridSize = gameMode.gridSize;
            tileSize = gameMode.tileSize;
            canvas.width = canvas.height = gridSize * tileSize;

            menuScreen.style.display = 'none';
            gameScreen.style.display = 'block';
            goofyKey.style.display = gameMode.goofy ? 'block' : 'none';
            battleKey.style.display = gameMode.battle ? 'block' : 'none';
            mazeKey.style.display = gameMode.maze ? 'block' : 'none';

            initGame();
            gameLoop = setInterval(update, gameSpeed);
            window.addEventListener('keydown', handleKeyPress);
        }

        function initGame() {
            gameOver = false;
            isPausedForCountdown = false;
            inMinigame = false;
            showingMinigameInstructions = false;
            gameSpeed = gameMode.startSpeed;
            obstacles = [];
            apples = [];
            
            snakes.forEach(s => {
                if (s.speedTimeout) clearTimeout(s.speedTimeout);
                if (s.reverseTimeout) clearTimeout(s.reverseTimeout);
                if (s.reverseCountdownInterval) clearInterval(s.reverseCountdownInterval);
            });
            snakes = [];

            if (gameMode.battle) {
                snakes.push({ id: 1, body: [{ x: 5, y: 10 }], color: '#00ff00', dx: -1, dy: 0, direction: 'left', inputQueue: [], controlsReversed: false });
                snakes.push({ id: 2, body: [{ x: 14, y: 10 }], color: '#0077ff', dx: 1, dy: 0, direction: 'right', inputQueue: [], controlsReversed: false });
            } else {
                const startPos = { x: Math.floor(gridSize/2), y: Math.floor(gridSize/2) };
                snakes.push({ id: 1, body: [startPos], color: '#00ff00', dx: 1, dy: 0, direction: 'right', inputQueue: [], limbs: [], controlsReversed: false });
                if (gameMode.goofy) {
                    snakes[0].color = goofyColors[colorIndex];
                }
            }
            
            if (gameMode.maze) {
                generateMaze(gameMode.pathWidth);
            }
            spawnApples();
            updateScores();
        }

        function spawnApples() {
            apples = [];
            let validSpaces = [];
            if (gameMode.maze) {
                const reachable = floodFill(snakes[0].body[0].x, snakes[0].body[0].y, maze);
                validSpaces = Array.from(reachable).map(key => {
                    const [x, y] = key.split(',').map(Number);
                    return {x, y};
                });
            }

            for (let i = 0; i < gameMode.appleCount; i++) {
                let validPosition = false;
                let newApple;
                while (!validPosition) {
                    let applePos;
                    if (gameMode.maze) {
                        applePos = validSpaces[Math.floor(Math.random() * validSpaces.length)];
                    } else {
                        applePos = { x: Math.floor(Math.random() * gridSize), y: Math.floor(Math.random() * gridSize) };
                    }
                    
                    newApple = {
                        x: applePos.x, y: applePos.y,
                        type: 'normal', color: '#ff0000', size: 1, vx: 0, vy: 0
                    };

                    if (gameMode.goofy) {
                        const rand = Math.random();
                        if (rand < 0.10) { newApple.type = 'super'; newApple.color = '#00ffff'; newApple.size = 2; } 
                        else if (rand < 0.20) { newApple.type = 'limb'; newApple.color = '#ffff00'; } 
                        else if (rand < 0.30) { newApple.type = 'moving'; newApple.color = '#9400D3'; newApple.vx = Math.random() > 0.5 ? 1 : -1; } 
                        else if (rand < 0.40) { newApple.type = 'reverse'; newApple.color = '#FFA500'; } 
                        else if (rand < 0.50) { newApple.type = 'shrink'; newApple.color = '#FFFFFF'; } 
                        else if (rand < 0.60) { newApple.type = 'obstacle'; newApple.color = '#808080'; } 
                        else if (rand < 0.70) { newApple.type = 'bonus'; newApple.color = '#FFD700'; }
                    } else if (gameMode.battle) {
                        const rand = Math.random();
                        if (rand < 0.33) { newApple.type = 'speed'; newApple.color = '#ffff00'; }
                        else if (rand < 0.66) { newApple.type = 'slow'; newApple.color = '#9400D3'; }
                        else { newApple.type = 'grow_other'; newApple.color = '#00ffff'; }
                    }
                    
                    if (newApple.x + newApple.size > gridSize) newApple.x = gridSize - newApple.size;
                    if (newApple.y + newApple.size > gridSize) newApple.y = gridSize - newApple.size;

                    validPosition = true;
                    snakes.forEach(s => s.body.forEach(p => { if(newApple.x === p.x && newApple.y === p.y) validPosition = false; }));
                    apples.forEach(a => { if(newApple.x === a.x && newApple.y === a.y) validPosition = false; });
                }
                apples.push(newApple);
            }
        }
        
        function update() {
            if (gameOver || showingMinigameInstructions || isPausedForCountdown) return;
            if (inMinigame) { updateMinigame(); return; }

            if (gameMode.battle) updateBattle();
            else updateSinglePlayer();
            
            if (!gameOver) draw();
        }

        function updateSinglePlayer() {
            const snake = snakes[0];
            if (snake.inputQueue.length > 0) {
                const nextMove = snake.inputQueue.shift();
                const canReverse = gameMode.maze;
                if (nextMove === 'left' && (canReverse || snake.direction !== 'right')) { snake.direction = 'left'; snake.dx = -1; snake.dy = 0; }
                if (nextMove === 'up' && (canReverse || snake.direction !== 'down')) { snake.direction = 'up'; snake.dx = 0; snake.dy = -1; }
                if (nextMove === 'right' && (canReverse || snake.direction !== 'left')) { snake.direction = 'right'; snake.dx = 1; snake.dy = 0; }
                if (nextMove === 'down' && (canReverse || snake.direction !== 'up')) { snake.direction = 'down'; snake.dx = 0; snake.dy = 1; }
            }

            apples.forEach(apple => { if (apple.type === 'moving') moveApple(apple); });

            const head = { x: snake.body[0].x + snake.dx, y: snake.body[0].y + snake.dy, color: snake.body[0].color, limbs: [] };
            snake.body.unshift(head);

            if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize || (gameMode.maze && maze[head.y][head.x] === 1)) return endGame();
            
            if (!gameMode.maze) {
                for (let i = 1; i < snake.body.length; i++) {
                    if (head.x === snake.body[i].x && head.y === snake.body[i].y) return endGame();
                    if (snake.body[i].limbs) {
                        for(const limb of snake.body[i].limbs) {
                            if(head.x === snake.body[i].x + limb.dx && head.y === snake.body[i].y + limb.dy) return endGame();
                        }
                    }
                }
            }
            
            for(const obstacle of obstacles) if(head.x === obstacle.x && head.y === obstacle.y) return endGame();

            let eatenApple = null;
            apples.forEach((apple) => {
                for (let i = 0; i < apple.size; i++) for (let j = 0; j < apple.size; j++) if (head.x === apple.x + i && head.y === apple.y + j) eatenApple = apple;
            });

            if (eatenApple) {
                if (eatenApple.type === 'bonus') { startMinigame(); return; }
                obstacles = [];
                if (gameMode.goofy) {
                    colorIndex = (colorIndex + 1) % goofyColors.length;
                    snake.body.forEach(part => part.color = goofyColors[colorIndex]);
                    if (eatenApple.type === 'limb') {
                        const limbTarget = snake.body.length > 2 ? snake.body[2] : snake.body[1];
                        const perp_dx = -snake.dy; const perp_dy = snake.dx;
                        limbTarget.limbs.push({ dx: perp_dx, dy: perp_dy });
                        limbTarget.limbs.push({ dx: perp_dx * 2, dy: perp_dy * 2 });
                        limbTarget.limbs.push({ dx: perp_dx - snake.dx, dy: perp_dy - snake.dy });
                    }
                    if (eatenApple.type === 'reverse') reverseControls();
                    if (eatenApple.type === 'shrink') if(snake.body.length > 3) { snake.body.pop(); snake.body.pop(); }
                    if (eatenApple.type === 'obstacle') createObstacles(eatenApple.x, eatenApple.y);
                }
                
                let lengthToAdd = ((eatenApple.type === 'super' || eatenApple.type === 'limb') && gameMode.goofy) ? 3 : 1;
                for(let i=0; i<lengthToAdd; i++) snake.body.push({...snake.body[snake.body.length-1]});
                snake.body.pop();

                if (gameMode.speedUp && gameSpeed > 60) {
                    gameSpeed -= 2.5;
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, gameSpeed);
                }
                
                spawnApples();
            } else {
                snake.body.pop();
            }
            updateScores();
        }

        function updateBattle() {
            snakes.forEach(snake => {
                if (snake.inputQueue.length > 0) {
                    const nextMove = snake.inputQueue.shift();
                    if (nextMove === 'left' && snake.direction !== 'right') { snake.direction = 'left'; snake.dx = -1; snake.dy = 0; }
                    if (nextMove === 'up' && snake.direction !== 'down') { snake.direction = 'up'; snake.dx = 0; snake.dy = -1; }
                    if (nextMove === 'right' && snake.direction !== 'left') { snake.direction = 'right'; snake.dx = 1; snake.dy = 0; }
                    if (nextMove === 'down' && snake.direction !== 'up') { snake.direction = 'down'; snake.dx = 0; snake.dy = 1; }
                }
                const head = { x: snake.body[0].x + snake.dx, y: snake.body[0].y + snake.dy };
                snake.body.unshift(head);
            });

            const p1 = snakes[0], p2 = snakes[1];
            const p1Head = p1.body[0], p2Head = p2.body[0];
            let p1Dead = false, p2Dead = false;

            if (p1Head.x < 0 || p1Head.x >= gridSize || p1Head.y < 0 || p1Head.y >= gridSize) p1Dead = true;
            if (p2Head.x < 0 || p2Head.x >= gridSize || p2Head.y < 0 || p2Head.y >= gridSize) p2Dead = true;
            for (let i = 1; i < p1.body.length; i++) if (p1Head.x === p1.body[i].x && p1Head.y === p1.body[i].y) p1Dead = true;
            for (let i = 1; i < p2.body.length; i++) if (p2Head.x === p2.body[i].x && p2Head.y === p2.body[i].y) p2Dead = true;
            
            if (p1Head.x === p2Head.x && p1Head.y === p2Head.y) {
                if (p1.body.length > p2.body.length) p2Dead = true;
                else if (p2.body.length > p1.body.length) p1Dead = true;
                else { p1Dead = true; p2Dead = true; }
            }
            
            for (let i = 0; i < p2.body.length; i++) if (p1Head.x === p2.body[i].x && p1Head.y === p2.body[i].y) p1Dead = true;
            for (let i = 0; i < p1.body.length; i++) if (p2Head.x === p1.body[i].x && p2Head.y === p1.body[i].y) p2Dead = true;

            if (p1Dead || p2Dead) return endGame(p1Dead, p2Dead);

            let eatenApple = false;
            apples.forEach((apple) => {
                snakes.forEach(snake => {
                    if (snake.body[0].x === apple.x && snake.body[0].y === apple.y) {
                        eatenApple = true;
                        snake.body.push({...snake.body[snake.body.length-1]});
                        const otherSnake = snakes.find(s => s.id !== snake.id);
                        if (apple.type === 'speed') {
                            clearTimeout(snake.speedTimeout);
                            clearInterval(gameLoop); gameSpeed = 100; gameLoop = setInterval(update, gameSpeed);
                            snake.speedTimeout = setTimeout(() => { clearInterval(gameLoop); gameSpeed = gameMode.startSpeed; gameLoop = setInterval(update, gameSpeed); }, 5000);
                        }
                        if (apple.type === 'slow') {
                            clearTimeout(otherSnake.speedTimeout);
                            clearInterval(gameLoop); gameSpeed = 350; gameLoop = setInterval(update, gameSpeed);
                            otherSnake.speedTimeout = setTimeout(() => { clearInterval(gameLoop); gameSpeed = gameMode.startSpeed; gameLoop = setInterval(update, gameSpeed); }, 5000);
                        }
                        if (apple.type === 'grow_other') for(let i=0; i<5; i++) otherSnake.body.push({...otherSnake.body[otherSnake.body.length-1]});
                    }
                });
            });

            if (eatenApple) {
                if (gameMode.speedUp && gameSpeed > 80) {
                    gameSpeed -= 3;
                    clearInterval(gameLoop);
                    gameLoop = setInterval(update, gameSpeed);
                }
                spawnApples();
            }
            else snakes.forEach(snake => snake.body.pop());
            updateScores();
        }

        function createObstacles(eatenAppleX, eatenAppleY) {
            for (let i = 0; i < 3; i++) {
                let validPosition = false;
                while(!validPosition) {
                    const obstacle = {
                        x: Math.floor(Math.random() * gridSize),
                        y: Math.floor(Math.random() * gridSize)
                    };
                    let isInvalid = false;
                    for(const part of snakes[0].body) {
                        if(obstacle.x === part.x && obstacle.y === part.y) {
                            isInvalid = true;
                            break;
                        }
                    }
                    if(isInvalid) continue;
                    const distance = Math.max(Math.abs(obstacle.x - eatenAppleX), Math.abs(obstacle.y - eatenAppleY));
                    if (distance < 3) isInvalid = true;
                    if (!isInvalid) {
                        obstacles.push(obstacle);
                        validPosition = true;
                    }
                }
            }
        }

        function moveApple(apple) {
            const allSnakeParts = snakes.flatMap(s => s.body);
            if (Math.random() < 0.1) {
                const directions = [{vx:1,vy:0}, {vx:-1,vy:0}, {vx:0,vy:1}, {vx:0,vy:-1}];
                const newDir = directions[Math.floor(Math.random() * directions.length)];
                apple.vx = newDir.vx; apple.vy = newDir.vy;
            }
            let nextX = apple.x + apple.vx;
            let nextY = apple.y + apple.vy;
            let bounce = false;
            for(const part of allSnakeParts) if(nextX === part.x && nextY === part.y) bounce = true;
            if (nextX < 0 || nextX >= gridSize) bounce = true;
            if (nextY < 0 || nextY >= gridSize) bounce = true;
            if(bounce) { apple.vx *= -1; apple.vy *= -1; }
            apple.x += apple.vx; apple.y += apple.vy;
            apple.x = Math.max(0, Math.min(gridSize - 1, apple.x));
            apple.y = Math.max(0, Math.min(gridSize - 1, apple.y));
        }

        function reverseControls() {
            const snake = snakes[0];
            snake.controlsReversed = true;
            reverseStatus.style.display = 'block';
            let countdown = 5;
            reverseTimerEl.textContent = `(${countdown})`;
            clearInterval(snake.reverseCountdownInterval); clearTimeout(snake.reverseTimeout);
            snake.reverseCountdownInterval = setInterval(() => {
                countdown--;
                reverseTimerEl.textContent = `(${countdown})`;
                if (countdown <= 0) clearInterval(snake.reverseCountdownInterval);
            }, 1000);
            snake.reverseTimeout = setTimeout(() => {
                snake.controlsReversed = false;
                reverseStatus.style.display = 'none';
            }, 5000);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if(gameMode.maze) {
                for (let y = 0; y < gridSize; y++) for (let x = 0; x < gridSize; x++) if (maze[y][x] === 1) { ctx.fillStyle = '#4d4d4d'; ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize); }
            }

            snakes.forEach(snake => {
                for(let i = 1; i < snake.body.length; i++) {
                    const part = snake.body[i];
                    ctx.fillStyle = snake.color;
                    ctx.fillRect(part.x * tileSize, part.y * tileSize, tileSize-1, tileSize-1);
                    if(part.limbs) part.limbs.forEach(limb => ctx.fillRect((part.x + limb.dx) * tileSize, (part.y + limb.dy) * tileSize, tileSize-1, tileSize-1));
                }
                const head = snake.body[0];
                ctx.fillStyle = snake.color;
                ctx.fillRect(head.x * tileSize, head.y * tileSize, tileSize-1, tileSize-1);
                ctx.fillStyle = '#000';
                const eyeSize = Math.max(3, tileSize / 6);
                const eyeOffset1 = tileSize / 5;
                const eyeOffset2 = tileSize - eyeOffset1 - eyeSize;
                if (snake.dx === 1) { ctx.fillRect(head.x * tileSize + eyeOffset2, head.y * tileSize + eyeOffset1, eyeSize, eyeSize); ctx.fillRect(head.x * tileSize + eyeOffset2, head.y * tileSize + eyeOffset2, eyeSize, eyeSize); } 
                else if (snake.dx === -1) { ctx.fillRect(head.x * tileSize + eyeOffset1, head.y * tileSize + eyeOffset1, eyeSize, eyeSize); ctx.fillRect(head.x * tileSize + eyeOffset1, head.y * tileSize + eyeOffset2, eyeSize, eyeSize); } 
                else if (snake.dy === 1) { ctx.fillRect(head.x * tileSize + eyeOffset1, head.y * tileSize + eyeOffset2, eyeSize, eyeSize); ctx.fillRect(head.x * tileSize + eyeOffset2, head.y * tileSize + eyeOffset2, eyeSize, eyeSize); } 
                else if (snake.dy === -1) { ctx.fillRect(head.x * tileSize + eyeOffset1, head.y * tileSize + eyeOffset1, eyeSize, eyeSize); ctx.fillRect(head.x * tileSize + eyeOffset2, head.y * tileSize + eyeOffset1, eyeSize, eyeSize); }
            });
            
            apples.forEach(apple => {
                ctx.fillStyle = apple.color;
                ctx.fillRect(apple.x * tileSize, apple.y * tileSize, tileSize * apple.size, tileSize * apple.size);
            });
            ctx.fillStyle = '#4d4d4d';
            obstacles.forEach(obstacle => ctx.fillRect(obstacle.x * tileSize, obstacle.y * tileSize, tileSize, tileSize));

            if(gameMode.maze) {
                const head = snakes[0].body[0];
                const visionMultiplier = gameMode.vision || 2;
                const gradient = ctx.createRadialGradient(
                    head.x * tileSize + tileSize / 2, head.y * tileSize + tileSize / 2, tileSize * visionMultiplier,
                    head.x * tileSize + tileSize / 2, head.y * tileSize + tileSize / 2, tileSize * (visionMultiplier + 2)
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,1)');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (currentModeName === 'easyMaze') {
                    apples.forEach(apple => {
                        ctx.fillStyle = apple.color;
                        ctx.fillRect(apple.x * tileSize, apple.y * tileSize, tileSize * apple.size, tileSize * apple.size);
                    });
                }
            }
        }
        
        function updateScores() {
            if (gameMode.battle) {
                scoreDisplay1.textContent = `P1 Score: ${snakes[0].body.length}`;
                scoreDisplay2.textContent = `P2 Score: ${snakes[1].body.length}`;
            } else {
                const score = snakes[0].body.length - 1;
                scoreDisplay1.textContent = `SCORE: ${score}`;
                if (score > highScore) highScore = score;
                scoreDisplay2.textContent = `HIGH: ${highScore}`;
            }
        }

        function endGame(p1Dead, p2Dead) {
            gameOver = true;
            clearInterval(gameLoop);
            window.removeEventListener('keydown', handleKeyPress);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#ff0000';
            ctx.font = `${tileSize * 1.5}px "Press Start 2P"`;
            ctx.textAlign = 'center';
            if(gameMode.battle) {
                let winnerText = "DRAW!";
                if(p1Dead && !p2Dead) winnerText = "P2 WINS!";
                if(p2Dead && !p1Dead) winnerText = "P1 WINS!";
                ctx.fillText(winnerText, canvas.width / 2, canvas.height / 2 - 20);
            } else {
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 20);
            }

            ctx.fillStyle = '#ffffff';
            ctx.font = `${tileSize * 0.6}px "Press Start 2P"`;
            ctx.fillText('Press Space to Restart', canvas.width / 2, canvas.height / 2 + 30);
            window.addEventListener('keydown', handleRestart);
        }

        function handleRestart(e) {
            if (e.keyCode === 32) {
                window.removeEventListener('keydown', handleRestart);
                startGame(currentModeName);
            }
        }

        function handleKeyPress(e) {
            if (gameOver || inMinigame || showingMinigameInstructions || isPausedForCountdown) return;
            
            const p1 = snakes[0];
            const p2 = gameMode.battle ? snakes[1] : null;

            if (p1.inputQueue.length < 3) {
                const p1LastDir = p1.inputQueue.length > 0 ? p1.inputQueue[p1.inputQueue.length - 1] : p1.direction;
                const canReverse = gameMode.maze;
                let key = e.key;
                if(p1.controlsReversed) {
                    if (key === 'w' || key === 'ArrowUp') key = 's';
                    else if (key === 's' || key === 'ArrowDown') key = 'w';
                    else if (key === 'a' || key === 'ArrowLeft') key = 'd';
                    else if (key === 'd' || key === 'ArrowRight') key = 'a';
                }

                if ((key === 'a' || (!gameMode.battle && key === 'ArrowLeft')) && (canReverse || p1LastDir !== 'right') && p1LastDir !== 'left') p1.inputQueue.push('left');
                if ((key === 'w' || (!gameMode.battle && key === 'ArrowUp')) && (canReverse || p1LastDir !== 'down') && p1LastDir !== 'up') p1.inputQueue.push('up');
                if ((key === 'd' || (!gameMode.battle && key === 'ArrowRight')) && (canReverse || p1LastDir !== 'left') && p1LastDir !== 'right') p1.inputQueue.push('right');
                if ((key === 's' || (!gameMode.battle && key === 'ArrowDown')) && (canReverse || p1LastDir !== 'up') && p1LastDir !== 'down') p1.inputQueue.push('down');
            }

            if (p2 && p2.inputQueue.length < 3) {
                const p2LastDir = p2.inputQueue.length > 0 ? p2.inputQueue[p2.inputQueue.length - 1] : p2.direction;
                if (e.key === 'ArrowLeft' && p2LastDir !== 'right' && p2LastDir !== 'left') p2.inputQueue.push('left');
                if (e.key === 'ArrowUp' && p2LastDir !== 'down' && p2LastDir !== 'up') p2.inputQueue.push('up');
                if (e.key === 'ArrowRight' && p2LastDir !== 'left' && p2LastDir !== 'right') p2.inputQueue.push('right');
                if (e.key === 'ArrowDown' && p2LastDir !== 'up' && p2LastDir !== 'down') p2.inputQueue.push('down');
            }
        }

        function showMenu() {
            clearInterval(gameLoop);
            window.removeEventListener('keydown', handleKeyPress);
            gameScreen.style.display = 'none';
            menuScreen.style.display = 'block';
        }

        // --- MAZE GENERATION (Recursive Backtracking) ---
        function generateMaze(pathWidth = 1) {
            maze = Array.from({ length: gridSize }, () => Array(gridSize).fill(1));
            const step = pathWidth === 1 ? 2 : 3;

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            function carve(x, y) {
                maze[y][x] = 0;
                if (pathWidth === 2) {
                    if (maze[y+1]) maze[y+1][x] = 0; 
                    if (maze[y][x+1]) maze[y][x+1] = 0; 
                    if (maze[y+1] && maze[y+1][x+1]) maze[y+1][x+1] = 0;
                }

                const directions = shuffle([ [0, -step], [step, 0], [0, step], [-step, 0] ]);

                for (const [dx, dy] of directions) {
                    const nx = x + dx, ny = y + dy;
                    if (ny > 0 && ny < gridSize - 1 && nx > 0 && nx < gridSize - 1 && maze[ny][nx] === 1) {
                        for (let i = 1; i < step; i++) {
                            const wallX = x + Math.round(dx/step*i);
                            const wallY = y + Math.round(dy/step*i);
                            maze[wallY][wallX] = 0;
                            if (pathWidth === 2) {
                                if(dx === 0) { if(maze[wallY]) maze[wallY][wallX+1] = 0; }
                                else { if(maze[wallY+1]) maze[wallY+1][wallX] = 0; }
                            }
                        }
                        carve(nx, ny);
                    }
                }
            }

            const startX = 1, startY = Math.floor(gridSize / 2);
            carve(startX, startY);
            
            for (let i = 0; i < 5; i++) {
                if (maze[startY] && maze[startY][startX+i] !== undefined) {
                    maze[startY][startX + i] = 0;
                    if(pathWidth === 2 && maze[startY+1]) maze[startY+1][startX + i] = 0;
                }
            }
            snakes[0].body = [{x:startX, y:startY}];
            snakes[0].dx = 1; snakes[0].dy = 0; snakes[0].direction = 'right';
        }

        function floodFill(startX, startY, mazeGrid) {
            const visited = new Set();
            const queue = [[startX, startY]];
            const key = (x, y) => `${x},${y}`;
            if (!mazeGrid[startY] || mazeGrid[startY][startX] !== 0) return visited;

            while (queue.length > 0) {
                const [x, y] = queue.shift();
                if (visited.has(key(x, y))) continue;
                visited.add(key(x, y));

                for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
                    const nx = x + dx, ny = y + dy;
                    if (ny >= 0 && ny < gridSize && nx >= 0 && nx < gridSize && mazeGrid[ny][nx] === 0 && !visited.has(key(nx, ny))) {
                        queue.push([nx, ny]);
                    }
                }
            }
            return visited;
        }

        // --- MINIGAME LOGIC ---
        function startMinigame() {
            showingMinigameInstructions = true;
            clearInterval(gameLoop);
            let countdown = 15;
            const drawInstructions = () => {
                draw();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#FFD700'; ctx.font = '30px "Press Start 2P"'; ctx.textAlign = 'center';
                ctx.fillText('BONUS STAGE!', canvas.width / 2, canvas.height / 2 - 80);
                ctx.fillStyle = '#ffffff'; ctx.font = '14px "Press Start 2P"';
                ctx.fillText('Jump over walls with SPACE.', canvas.width / 2, canvas.height / 2 - 20);
                ctx.fillText('Earn +1 score per jump!', canvas.width / 2, canvas.height / 2 + 10);
                ctx.font = '20px "Press Start 2P"';
                ctx.fillText(`Starts in: ${countdown}`, canvas.width / 2, canvas.height / 2 + 70);
                ctx.font = '14px "Press Start 2P"';
                ctx.fillText('(Press SPACE to start now)', canvas.width / 2, canvas.height / 2 + 110);
            };
            drawInstructions();
            minigameInstructionCountdownInterval = setInterval(() => {
                countdown--; drawInstructions();
                if (countdown <= 0) beginMinigameLoop();
            }, 1000);
            minigameInstructionTimeout = setTimeout(beginMinigameLoop, 15000);
            window.addEventListener('keydown', handleMinigameStartKey);
        }
        function handleMinigameStartKey(e) { if (e.keyCode === 32) beginMinigameLoop(); }
        function beginMinigameLoop() {
            window.removeEventListener('keydown', handleMinigameStartKey);
            clearTimeout(minigameInstructionTimeout);
            clearInterval(minigameInstructionCountdownInterval);
            showingMinigameInstructions = false; inMinigame = true;
            minigame = { player: { x: 2, y: gridSize - 1, vy: 0, color: snakes[0].body[0].color }, gravity: 0.5, jumpPower: -7, obstacles: [], obstacleSpeed: 0.25, spawnTimer: 0, timeLeft: 10 };
            messageEl.textContent = "BONUS ROUND! JUMP!";
            window.addEventListener('keydown', handleMinigameJump);
            gameLoop = setInterval(update, 20);
            minigameTimerInterval = setInterval(() => {
                minigame.timeLeft--;
                if(minigame.timeLeft <= 0) {
                    clearInterval(minigameTimerInterval);
                    endMinigame();
                }
            }, 1000);
        }
        function handleMinigameJump(e) { if (e.keyCode === 32 && minigame.player.y === gridSize - 1) minigame.player.vy = minigame.jumpPower; }
        function updateMinigame() {
            minigame.player.vy += minigame.gravity; minigame.player.y += minigame.player.vy;
            if (minigame.player.y >= gridSize - 1) { minigame.player.y = gridSize - 1; minigame.player.vy = 0; }
            minigame.spawnTimer--;
            if (minigame.spawnTimer <= 0) {
                minigame.obstacles.push({ x: gridSize, width: 1, height: 2 });
                minigame.spawnTimer = Math.random() * 80 + 60;
            }
            for (let i = minigame.obstacles.length - 1; i >= 0; i--) {
                const obs = minigame.obstacles[i];
                obs.x -= minigame.obstacleSpeed;
                if (obs.x + obs.width < 0) {
                    minigame.obstacles.splice(i, 1);
                    snakes[0].body.push({...snakes[0].body[snakes[0].body.length-1]});
                    updateScores();
                }
                if (minigame.player.x < obs.x + obs.width && minigame.player.x + 1 > obs.x && minigame.player.y < (gridSize - 1) + obs.height && minigame.player.y + 1 > gridSize - obs.height) {
                    clearInterval(minigameTimerInterval);
                    endMinigame();
                }
            }
            drawMinigame();
        }
        function drawMinigame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = minigame.player.color;
            ctx.fillRect(minigame.player.x * tileSize, minigame.player.y * tileSize, tileSize, tileSize);
            ctx.fillStyle = '#ff0000';
            minigame.obstacles.forEach(obs => ctx.fillRect(obs.x * tileSize, (gridSize - obs.height) * tileSize, obs.width * tileSize, obs.height * tileSize));
            ctx.fillStyle = '#ffffff'; ctx.font = '24px "Press Start 2P"'; ctx.textAlign = 'left';
            ctx.fillText(`TIME: ${minigame.timeLeft}`, 10, 30);
        }
        function endMinigame() {
            inMinigame = false; clearInterval(gameLoop);
            window.removeEventListener('keydown', handleMinigameJump);
            messageEl.textContent = "";
            startResumeCountdown();
        }
        function startResumeCountdown() {
            isPausedForCountdown = true;
            let countdown = 3;
            const drawCountdown = () => {
                draw();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffffff'; ctx.font = '80px "Press Start 2P"'; ctx.textAlign = 'center';
                ctx.fillText(countdown, canvas.width / 2, canvas.height / 2 + 30);
            };
            drawCountdown();
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) drawCountdown();
                else {
                    clearInterval(countdownInterval);
                    isPausedForCountdown = false;
                    spawnApples();
                    gameLoop = setInterval(update, gameSpeed);
                }
            }, 1000);
        }
    </script>

</body>
</html>
